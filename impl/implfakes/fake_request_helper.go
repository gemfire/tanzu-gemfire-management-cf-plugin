// Code generated by counterfeiter. DO NOT EDIT.
package implfakes

import (
	"sync"

	"github.com/gemfire/cloudcache-management-cf-plugin/domain"
	"github.com/gemfire/cloudcache-management-cf-plugin/impl"
)

type FakeRequestHelper struct {
	ExecuteCommandStub        func(string, string, *domain.CommandData) (string, error)
	executeCommandMutex       sync.RWMutex
	executeCommandArgsForCall []struct {
		arg1 string
		arg2 string
		arg3 *domain.CommandData
	}
	executeCommandReturns struct {
		result1 string
		result2 error
	}
	executeCommandReturnsOnCall map[int]struct {
		result1 string
		result2 error
	}
	GetEndPointsStub        func(*domain.CommandData) error
	getEndPointsMutex       sync.RWMutex
	getEndPointsArgsForCall []struct {
		arg1 *domain.CommandData
	}
	getEndPointsReturns struct {
		result1 error
	}
	getEndPointsReturnsOnCall map[int]struct {
		result1 error
	}
	GetTargetAndClusterCommandStub        func([]string) (string, domain.UserCommand)
	getTargetAndClusterCommandMutex       sync.RWMutex
	getTargetAndClusterCommandArgsForCall []struct {
		arg1 []string
	}
	getTargetAndClusterCommandReturns struct {
		result1 string
		result2 domain.UserCommand
	}
	getTargetAndClusterCommandReturnsOnCall map[int]struct {
		result1 string
		result2 domain.UserCommand
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeRequestHelper) ExecuteCommand(arg1 string, arg2 string, arg3 *domain.CommandData) (string, error) {
	fake.executeCommandMutex.Lock()
	ret, specificReturn := fake.executeCommandReturnsOnCall[len(fake.executeCommandArgsForCall)]
	fake.executeCommandArgsForCall = append(fake.executeCommandArgsForCall, struct {
		arg1 string
		arg2 string
		arg3 *domain.CommandData
	}{arg1, arg2, arg3})
	fake.recordInvocation("ExecuteCommand", []interface{}{arg1, arg2, arg3})
	fake.executeCommandMutex.Unlock()
	if fake.ExecuteCommandStub != nil {
		return fake.ExecuteCommandStub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.executeCommandReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeRequestHelper) ExecuteCommandCallCount() int {
	fake.executeCommandMutex.RLock()
	defer fake.executeCommandMutex.RUnlock()
	return len(fake.executeCommandArgsForCall)
}

func (fake *FakeRequestHelper) ExecuteCommandCalls(stub func(string, string, *domain.CommandData) (string, error)) {
	fake.executeCommandMutex.Lock()
	defer fake.executeCommandMutex.Unlock()
	fake.ExecuteCommandStub = stub
}

func (fake *FakeRequestHelper) ExecuteCommandArgsForCall(i int) (string, string, *domain.CommandData) {
	fake.executeCommandMutex.RLock()
	defer fake.executeCommandMutex.RUnlock()
	argsForCall := fake.executeCommandArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeRequestHelper) ExecuteCommandReturns(result1 string, result2 error) {
	fake.executeCommandMutex.Lock()
	defer fake.executeCommandMutex.Unlock()
	fake.ExecuteCommandStub = nil
	fake.executeCommandReturns = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeRequestHelper) ExecuteCommandReturnsOnCall(i int, result1 string, result2 error) {
	fake.executeCommandMutex.Lock()
	defer fake.executeCommandMutex.Unlock()
	fake.ExecuteCommandStub = nil
	if fake.executeCommandReturnsOnCall == nil {
		fake.executeCommandReturnsOnCall = make(map[int]struct {
			result1 string
			result2 error
		})
	}
	fake.executeCommandReturnsOnCall[i] = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeRequestHelper) GetEndPoints(arg1 *domain.CommandData) error {
	fake.getEndPointsMutex.Lock()
	ret, specificReturn := fake.getEndPointsReturnsOnCall[len(fake.getEndPointsArgsForCall)]
	fake.getEndPointsArgsForCall = append(fake.getEndPointsArgsForCall, struct {
		arg1 *domain.CommandData
	}{arg1})
	fake.recordInvocation("GetEndPoints", []interface{}{arg1})
	fake.getEndPointsMutex.Unlock()
	if fake.GetEndPointsStub != nil {
		return fake.GetEndPointsStub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.getEndPointsReturns
	return fakeReturns.result1
}

func (fake *FakeRequestHelper) GetEndPointsCallCount() int {
	fake.getEndPointsMutex.RLock()
	defer fake.getEndPointsMutex.RUnlock()
	return len(fake.getEndPointsArgsForCall)
}

func (fake *FakeRequestHelper) GetEndPointsCalls(stub func(*domain.CommandData) error) {
	fake.getEndPointsMutex.Lock()
	defer fake.getEndPointsMutex.Unlock()
	fake.GetEndPointsStub = stub
}

func (fake *FakeRequestHelper) GetEndPointsArgsForCall(i int) *domain.CommandData {
	fake.getEndPointsMutex.RLock()
	defer fake.getEndPointsMutex.RUnlock()
	argsForCall := fake.getEndPointsArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeRequestHelper) GetEndPointsReturns(result1 error) {
	fake.getEndPointsMutex.Lock()
	defer fake.getEndPointsMutex.Unlock()
	fake.GetEndPointsStub = nil
	fake.getEndPointsReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeRequestHelper) GetEndPointsReturnsOnCall(i int, result1 error) {
	fake.getEndPointsMutex.Lock()
	defer fake.getEndPointsMutex.Unlock()
	fake.GetEndPointsStub = nil
	if fake.getEndPointsReturnsOnCall == nil {
		fake.getEndPointsReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.getEndPointsReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeRequestHelper) GetTargetAndClusterCommand(arg1 []string) (string, domain.UserCommand) {
	var arg1Copy []string
	if arg1 != nil {
		arg1Copy = make([]string, len(arg1))
		copy(arg1Copy, arg1)
	}
	fake.getTargetAndClusterCommandMutex.Lock()
	ret, specificReturn := fake.getTargetAndClusterCommandReturnsOnCall[len(fake.getTargetAndClusterCommandArgsForCall)]
	fake.getTargetAndClusterCommandArgsForCall = append(fake.getTargetAndClusterCommandArgsForCall, struct {
		arg1 []string
	}{arg1Copy})
	fake.recordInvocation("GetTargetAndClusterCommand", []interface{}{arg1Copy})
	fake.getTargetAndClusterCommandMutex.Unlock()
	if fake.GetTargetAndClusterCommandStub != nil {
		return fake.GetTargetAndClusterCommandStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.getTargetAndClusterCommandReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeRequestHelper) GetTargetAndClusterCommandCallCount() int {
	fake.getTargetAndClusterCommandMutex.RLock()
	defer fake.getTargetAndClusterCommandMutex.RUnlock()
	return len(fake.getTargetAndClusterCommandArgsForCall)
}

func (fake *FakeRequestHelper) GetTargetAndClusterCommandCalls(stub func([]string) (string, domain.UserCommand)) {
	fake.getTargetAndClusterCommandMutex.Lock()
	defer fake.getTargetAndClusterCommandMutex.Unlock()
	fake.GetTargetAndClusterCommandStub = stub
}

func (fake *FakeRequestHelper) GetTargetAndClusterCommandArgsForCall(i int) []string {
	fake.getTargetAndClusterCommandMutex.RLock()
	defer fake.getTargetAndClusterCommandMutex.RUnlock()
	argsForCall := fake.getTargetAndClusterCommandArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeRequestHelper) GetTargetAndClusterCommandReturns(result1 string, result2 domain.UserCommand) {
	fake.getTargetAndClusterCommandMutex.Lock()
	defer fake.getTargetAndClusterCommandMutex.Unlock()
	fake.GetTargetAndClusterCommandStub = nil
	fake.getTargetAndClusterCommandReturns = struct {
		result1 string
		result2 domain.UserCommand
	}{result1, result2}
}

func (fake *FakeRequestHelper) GetTargetAndClusterCommandReturnsOnCall(i int, result1 string, result2 domain.UserCommand) {
	fake.getTargetAndClusterCommandMutex.Lock()
	defer fake.getTargetAndClusterCommandMutex.Unlock()
	fake.GetTargetAndClusterCommandStub = nil
	if fake.getTargetAndClusterCommandReturnsOnCall == nil {
		fake.getTargetAndClusterCommandReturnsOnCall = make(map[int]struct {
			result1 string
			result2 domain.UserCommand
		})
	}
	fake.getTargetAndClusterCommandReturnsOnCall[i] = struct {
		result1 string
		result2 domain.UserCommand
	}{result1, result2}
}

func (fake *FakeRequestHelper) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.executeCommandMutex.RLock()
	defer fake.executeCommandMutex.RUnlock()
	fake.getEndPointsMutex.RLock()
	defer fake.getEndPointsMutex.RUnlock()
	fake.getTargetAndClusterCommandMutex.RLock()
	defer fake.getTargetAndClusterCommandMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeRequestHelper) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ impl.RequestHelper = new(FakeRequestHelper)
